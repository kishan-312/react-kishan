âœ… Category 1 â€” State Update & Re-render Logic

========================= state update on prev state value or old state value (if same define then overwrite)
Question 4
What will be the output of the following code?
function Demo() {
  const [num, setNum] = useState(10);

  function update() {
    setNum(num + 5);
    setNum(num + 10);
  }

  return (
    <div>
      <p>{num}</p>
      <button onClick={update}>Update</button>
    </div>
  );
}

â“ After clicking the button once, what will be the final value displayed on screen? Explain why.
âœ… Answer
Final displayed value: 20

â€”not 25.

ðŸ§  Explanation
Key point:

Both state updates use the same captured value of num, which is 10 when update() runs.

Let's break it down:

Line	Code	What it calculates	What it requests React to set
1	setNum(num + 5)	10 + 5	requests num = 15
2	setNum(num + 10)	10 + 10	requests num = 20

React batches the updates and applies the last requested state, so:

Final num = 20


The first update (15) is overwritten by the second update (20).

âœ… If you want increment based on previous state, do this:
function update() {
  setNum(prev => prev + 5);
  setNum(prev => prev + 10);
}


Now React applies updates sequentially:

First: 10 + 5 = 15

Second: 15 + 10 = 25

Final result becomes:
25 âœ…

ðŸŽ¯ Interview Answer (Say this confidently)

State updates depending on the previous state should always use the functional updater form. Otherwise, the state updates may use stale values and the last update will overwrite earlier ones.


////////////// why overwrite 
Awesome â€” this question shows deep understanding.
Letâ€™s explain it very simply and clearly âœ…

ðŸ§  Key Idea

When you write:

setCount(count + 1)


You are using the current renderâ€™s count value (a stale snapshot).

But when you write:

setCount(prev => prev + 1)


You are using the most recent updated state, not the stale one.

ðŸ” Why "stale" happens?

React does not update state immediately.

It schedules updates and batches multiple updates into one render.

So during the render:

count is a fixed value.


Even if you call setCount 10 times,
count doesn't change during that render.

âŒ Without prev (Overwrites)
setCount(count + 1)
setCount(count + 1)


Assume count = 0.

Update	Value Used	Result
1st update	0 + 1	requests to set 1
2nd update	0 + 1	also requests to set 1

Both updates use the same old value (0).
So final state becomes:

count = 1 (second update overwrites the first)


âœ… This is what â€œoverwriteâ€ means.

âœ… With prev (Does Not Overwrite)
setCount(prev => prev + 1)
setCount(prev => prev + 1)


Assume count = 0.

Update	prev Value	Result
1st update	0	set to 1
2nd update	1	set to 2

So final state becomes:

count = 2


Because each update sees the latest state, not the stale one.

ðŸŽ¯ Final Explanation (Say This in Interview)

When updates depend on previous state, you must use the functional updater form because React batches state updates. Without the functional form, every update reads the same stale state value, so later updates overwrite earlier ones. The functional updater receives the latest state, ensuring each update is applied correctly.

ðŸ§  Super Short Memory Trick
Form	Uses Which Value?	Result when called twice
setCount(count + 1)	Old stale count	Ends at +1
setCount(prev => prev + 1)	Updated count each time	Ends at +2









