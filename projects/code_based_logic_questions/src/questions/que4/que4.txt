âœ… Category 1 â€” State Update & Re-render Logic
Question 3
What will happen in the following code?
function Example() {
  const [value, setValue] = useState({ count: 0 });

  function increase() {
    value.count = value.count + 1;
    setValue(value);
    console.log("value.count inside:", value.count);
  }

  return (
    <div>
      <p>{value.count}</p>
      <button onClick={increase}>Increase</button>
    </div>
  );
}

â“ When the button is clicked, what will be printed and will the UI update? Explain.
âœ… Answer
Console Output
value.count inside: 1

UI will NOT update. The displayed count stays 0.
ðŸ§  Explanation
1) State should not be mutated directly
value.count = value.count + 1;


This mutates the existing object, instead of creating a new object.

2) setValue(value) passes the same object reference

React checks object identity to decide whether to re-render.

Since the reference didnâ€™t change â†’ React skips rendering.

3) Thatâ€™s why UI does not change, even though the object value changed.
âœ… Correct Fix (Immutable Update)

Create a new object, donâ€™t modify the old one:

setValue(prev => ({ ...prev, count: prev.count + 1 }));


This ensures React sees a new reference, causing re-render.

âš¡ Interview Key Answer (What to say)

React state should never be mutated directly. React compares state by reference, so if the reference does not change, React will not re-render. Always create a new copy when updating object/array state.

ðŸŸ¢ Quick Practice Variation

If the state was an array, how would you add one new item?

Correct Answer:

setValue(prev => [...prev, newItem]);
