Great question âœ…
Interviewers love to ask this.

Where can you use useState?
Location	Allowed?	Why
At the top of a React function component	âœ… Yes	React needs hook order to remain consistent
Inside a custom hook (a function that starts with use)	âœ… Yes	Custom hooks follow same rules as components
Inside loops	âŒ No	Hook order changes â†’ React gets confused
Inside conditions (if, else)	âŒ No	Sometimes hook runs, sometimes not â†’ breaks state order
Inside nested functions	âŒ No	Hook gets called unpredictably
Inside class components	âŒ No	Hooks only work in functional components
âœ… Correct Example (Allowed)
function App() {
  const [count, setCount] = useState(0); // âœ… Top level

  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}

âŒ Wrong Example (Not Allowed)
Inside a condition:
function App() {
  if (true) {
    const [count, setCount] = useState(0); // âŒ Not allowed
  }
}

Inside a loop:
function App() {
  for (let i = 0; i < 3; i++) {
    const [value, setValue] = useState(i); // âŒ Not allowed
  }
}

Inside another function:
function App() {
  function someWork() {
    const [count, setCount] = useState(0); // âŒ Not allowed
  }
}

âœ… Allowed inside a custom hook
function useCounter() {
  const [count, setCount] = useState(0); // âœ… Allowed
  return [count, setCount];
}

function App() {
  const [count, setCount] = useCounter(); // âœ… Allowed
  return <div>{count}</div>;
}

ğŸ”¥ Why does React restrict this?

Because React Hooks depend on the order in which they are called.

React keeps a list like:

Hook 1 -> useState
Hook 2 -> useEffect
Hook 3 -> useState


If you put hooks inside if or loops, the order changes â†’ React gets confused and breaks state.

ğŸ§  Shortcut Rule to Remember

Hooks must be called at the top level of a React function component or a custom hook.

Not inside conditions, loops, or nested functions.


========================= order of hook ===============

ğŸ§  Order of Hooks Meaning
React hooks must be called in the exact same order every time your component renders.
React keeps an internal list like:
Hook #1 -> useState(...)
Hook #2 -> useEffect(...)
Hook #3 -> useState(...)
Hook #4 -> useRef(...)

React does not track hooks by name
React tracks hooks by position (order).
So if order changes â†’ React applies the wrong state/effect to the wrong hook â†’ break.

âœ… Correct Example (Same order every render)
function App() {
  const [count, setCount] = useState(0);  // Hook #1
  const [name, setName] = useState("Kishan"); // Hook #2

  useEffect(() => {                        // Hook #3
    console.log("Rendered");
  }, []);

  return <div>{count} - {name}</div>;
}

Hook Order Table
Hook CallOrder PositionTypeuseState(0)#1stateuseState("Kishan")#2stateuseEffect()#3effect
This is stable â†’ React knows what to update.

âŒ Wrong Example (Breaking order)
function App({ show }) {
  const [count, setCount] = useState(0); // Hook #1

  if (show) {
    const [name, setName] = useState("Kishan"); // âŒ Hook order changes
  }

  useEffect(() => {                     // This may become Hook #2 or #3!
    console.log("Rendered");
  }, []);
}

Why this breaks?


If show = true: useState("Kishan") is Hook #2


If show = false: useEffect() becomes Hook #2


So React gets confused like:
Waitâ€¦ last render Hook #2 was state, now it's effect? ğŸ˜µ


ğŸ§© Memory Trick
âœ… Allowed:


Top-level of component


Top-level of custom hook


âŒ Not Allowed:


Inside if


Inside loops


Inside nested functions



ğŸ¤ Interview Answer (Simple & Clean)

Hooks must always be called in the same order because React identifies hook states by the order they appear in the component. If the order changes between renders, React canâ€™t match the current hook call to its previous state, causing bugs. Thatâ€™s why hooks must be called at the top-level and never inside loops, conditions, or nested functions.


If you're ready, say:
"Give me order-of-hooks question in code form"
And Iâ€™ll send you a tricky interview code snippet + explanation ğŸ˜


======================================== (loop conditions not allow, inside component body not allow)



Great â€” letâ€™s clear this very important interview topic:

Where can you call setState (like setCount), and where can you NOT call it?

âœ… Where You CAN Call setState
Place	Allowed?	Why
Inside event handlers	âœ… Yes	This is the most common use case
Inside useEffect	âœ… Yes	To update state after side effects
Inside useCallback, useMemo callbacks	âœ… Yes	Still controlled and stable
Inside async functions / API calls	âœ… Yes	Works fine
Inside custom hooks	âœ… Yes	Same rules as components
âœ… Example (Event Handler)
function App() {
  const [count, setCount] = useState(0);

  function add() {
    setCount(count + 1);
  }

  return <button onClick={add}>{count}</button>;
}

âœ… Example (Inside useEffect)
useEffect(() => {
  setCount(prev => prev + 1);
}, []);

âœ… Example (Inside async function)
async function fetchData() {
  const data = await fetch("/api");
  setUser(data.user);
}

âŒ Where You CANNOT Call setState
Place	Not Allowed?	Reason
Directly inside component body (top-level)	âŒ Causes infinite re-render loop	
Inside useMemo return	âŒ Must remain pure	
Inside useEffect cleanup	âŒ Cleanup must be pure	
Inside render logic (like mapping)	âŒ It re-renders while rendering â€“ infinite loop	
Inside loops, conditions, or nested functions	âš ï¸ Allowed technically, but can break logic or cause infinite loops	
âŒ Example (Bad â€“ causes infinite re-render)
function App() {
  const [count, setCount] = useState(0);

  setCount(count + 1); // âŒ Runs every render â†’ infinite loop

  return <div>{count}</div>;
}

âŒ Example (Bad â€“ inside render mapping)
items.map(item => {
  setCount(prev => prev + 1); // âŒ Will update state while rendering
});

âŒ Example (Bad â€“ inside useEffect cleanup)
useEffect(() => {
  return () => {
    setCount(5); // âŒ Not allowed in cleanup
  };
}, []);

ğŸ‘ Safe Summary to Speak in Interview

You can call setState inside event handlers, effects, async callbacks, and custom hooks.
You should NOT call it directly in the component body during render, inside cleanup functions, or anywhere that causes the state to update while rendering.
Doing that leads to infinite re-renders.











